---
layout: single
title: "[Certificate] 정보처리기사 필기 - [2과목] 소프트웨어 개발 - 총정리"
categories: Study
tag: [Study, Certificate]

toc: true
toc_sticky: true
published: true

date: 2022-04-23
last_modified_at: 2022-04-23

---


📄 [**정보처리기사 필기 기출 (개정 후)**](https://comcbt.com/xe/iz)를 공부하고 정리한 포스트입니다.
{: .notice--primary}


### 스키마

- 외부 스키마
    - 개인 또는 응용 개발자 입장에서 보는 DB
- 개념 스키마
    - 모든 응용 프로그램 또는 사용자들이 필요로 하는 조직 전체 DB로 단 하나만 존재
- `내부 스키마`
    - `물리적` 저장 장치의 입장에서 본 DB 구조
    - 실제 DB에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타냄

---

### SW 프로젝트 관리

- 주어진 기간 내에 최소의 비용으로 사용자를 만족시키는 시스템을 개발
- 소프트웨어 개발 계획을 세우고 작업을 통제하는 것
- 소프트웨어 `생명 주기의 전 과정`에 걸쳐 진행됨
- 소요인력은 최소화 하는 것이 좋음

---

### SW 테스트

- 검증(Veritication)
    - SW가 `요구사항`에 부합하게 구현
- 확인(Validation)
    - SW가 `고객` 의도에 따라 구현

---

### ❗️검증(Validation) 검사 기법

- 형상검사
    - 구성요소, 목록, 유지보수 모든 사항이 표현되었나 검사
- `알파검사`(인수테스트 종류)
    - `사용자가 개발자 앞`에서 행하는 검사
- 베타검사(인수테스트 종류)
    - 사용자가 여러 명의 사용자 앞에서 행하는 테스트
- 디버깅
    - 개발 단계 중 버그를 찾아내고 원인을 밝히고 수정하는 작업 과정
- 자료구조 검사
    - 자료형태, 변수 초기화, 자료 형태의 일관성 테스트

---

### SW 테스트

- ❗️화이트 박스 테스트
    - 내부 구조 동작 검사 ⇒ `내부 소스` 테스트
    - 내부 논리적인 `모든 경로` 테스트
    - `개발자 관점`의 단위 테스트
- ❗️블랙 박스 테스트
    - 내부 구조, 작동 원리 모르는 상태에서 ⇒ `동작` 테스트
    - `사용자 관점` 테스트
    - 동치 클래스 분해, `경계값` 분석, 원인 결과 그래프

---

### SW 테스트 기본원칙

- 살충제 패러독스
    - 동일한 테스트 케이스로 반복 실행하면 더이상 새로운 결함을 발견할 수 없음 ⇒ 주기적으로 테스트 케이스를 점검, 개선
- 오류 부재의 궤변
    - 사용자의 요구사항을 만족하지 못한다면 오류를 발견하고 제거해도 품질이 높다고 말할 수 없음
- `파레토 법칙`
    - 오류의 80%는 전체의 20% 내에서 발견
- `Brooks의 법칙`
    - 지연되는 프로젝트에 인력을 더 투입하면 오히려 더 늦어짐

---

### 테스트

- `테스트 오라클`
    - 테스트 결과가 참인지 거짓인지를 판단하기 위해
    - 사전에 정의된 참값을 입력해 비교하는 기법
- 테스트 케이스
    - 구현된 SW가 사용자의 요구사항을 정확하게 준수했는지 확인하기 위해
    - 설계된 입력 값, 실행 조건, 기대 결과로 구성
- 테스트 시나리오
    - 테스트 케이스를 적용하는 순서에 따라 여러 개 테스트 케이스 묶은 집합

---

### 테스트 자동화 기구

- `성능` 테스트 도구
    - `애플리케이션 처리량, 응답시간, 경과시간, 자원사용률` 테스트
    - 가상 사용자 만들어 테스트 수행

---

### 테스트 케이스 구성요소

- 테스트 조건
- 테스트 데이터
- 예상 결과

---

### 테스트

- ❗️`테스트 드라이버`
    - `하위 모듈을 호출`하고, `파라미터`를 전달, 모듈 테스트 수행 후 결과 도출
    - `상향식` 테스트
- ❗️테스트 스텁
    - 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구
    - `일시적으로 필요한 조건`만 가지고 있는 시험용 모듈
    - `하향식` 테스트
- 테스트 슈트
    - 테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스의 집합
- 테스트 케이스
    - 사용자의 요구사항을 정확히 준수했는지 확인하기 위한 테스트 항목의 명세서

---

### 모듈 테스트

- ❗️`단위 테스트`
    - `하나의 모듈`을 기준으로 `독립`적으로 진행
    - 가장 작은 단위 테스트
    - 내부의 논리적 오류, 기능 점검
- 통합 테스트
    - `모듈 간`의 호환성 확인
- 시스템 테스트
    - `완전한 시스템`에 대해 수행
    - 기능적, 비기능적 `요구사항` 확인
- 인수
    - 실제 환경에서 `사용자`가 참여
    - `요구 분석 명세서` 충족 확인

---

### 시스템 테스트

- `강도 테스트`
    - `과다 정보량` 부과해 시스템 정상 작동 확인
- 회복 테스트
    - 고의 실패 유도 → 정상 `복귀` 테스트
- `성능` 테스트
    - 응답 시간, 처리 업무량, 반응 속도 테스트
- 안전 테스트
    - 불법, 보안

---

### 시스템 능력

- `Portability`(이식성)
    - 다양한 하드웨어 환경에서도 운용 가능하도록 `쉽게 수정` 가능
- Efficienty(효율성)
    - 최소의 작업으로 요구되는 기능을 수행
- Usability(사용 용이성)
    - SW를 쉽게 사용할 수 있는 정도
- Correctness(정확성)
    - 사용자의 요구사항 충족

---

### ❗️SW 품질 측정

- 기능성
    - 사용자 요구사항을 정확하게 만족하는 기능을 제공하는지 여부
- `신뢰성`
    - 요구된 기능을 정확하고 `일관`되게 오류없이 수행할 수 있는 정도
- `사용성`
    - 사용자와 컴퓨터 사이에 발생하는 어떠한 행위에 대해 사용자가 정확하게 이해하고 사용하며 향후 다시 사용하고 싶은 정도
- 효율성
    - 요구하는 기능을 할당된 시간동안 한정된 자원으로 얼마나 빨리 처리할 수 있는지 정도
- 유지 보수성
    - 환경 변화 or 새 요구사항 발생 시 소프트웨어 개선 및 확장할 수 있는 정도
- 이식성
    - 타 환경에서도 얼마나 쉽게 적용할 수 있는지 정도
- `정확성`
- `무결성`

---

### SW 버전 등록

- `형상 감사`
    - `기준선`의 무결성을 평가
    - 확인, 검증, 검열 과정
- 저장소
    - 최신 버전의 파일, 변경 내역에 대한 정보 저장된 곳
- 가져오기(import)
    - 아무것도 없는 저장소에 처음으로 파일 복사
- `체크인`
    - 파일 수정 완료 후 저장소의 파일을 새로운 버전으로 `갱신`

---

### SW 버전 관리도구

- `분산 저장소 방식`
    - 원격 저장소, 로컬 저장소에 함께 저장되어 관리
    - 로컬 저장소에서 우선 반영(Commit) ⇒ 원격 저장소에 반영(Push)
    - 로컬 저장소에서 작업속도 빠름
- 공유 폴더 방식
    - 로컬 컴퓨터의 공유 폴더에 저장되어 관리
    - 공유 폴더의 파일을 자기 PC로 복사 후 이상 유무 확인
- 클라이언트-서버 방식
    - 중앙 시스템(서버)에 저장되어 관리
    - 개별자별로 자신의 PC(클라이언트)로 복사
    - 모든 버전 관리는 서버에서 수행
    - 서버에 문제 생기면 다른 개발자 협업, 버전 관리 작업 중단

---

### 형상 관리 항목

- 프로젝트 요구 분석서
- 소스 코드
- 운영 및 설치 지침서

---

### ❗️SW 패키징

- 모듈별로 생성한 실행 파일들을 하나로 합쳐서 설치 파일을 만드는 것
- 사용자에게 배포되는 SW이므로 보안 고려
- 사용자 편의성을 위한 복합성, 비효율성 문제 고려
- 제품 SW 종류에 적합한 암호화 알고리즘 적용
- `사용자 중심`

---

### ❗️EAI (Enterprise Application Integration)

- `Point-to-Point`
    - 가장 기본적인 애플리케이션 통합 방식
    - 애플리케이션을 `1:1` 로 연결
    - 변경 및 재사용이 어려움
- `Hub & Spoke`
    - 단일 접점인 허브를 통해 데이터를 전송하는 중앙 집중형 방식
    - 확장 및 유지 보수가 용이
    - 허브 장애 발생 시 시스템 전체에 영향
- `Message Bus` (ESB 방식)
    - 애플리케이션 사이에 미들웨어를 두어 처리하는 방식
    - 확장성이 뛰어나며 `대용량` 처리가 가능
- Hybrid
    - 그룹 내에서는 Hub & Spoke 방식
    - 그룹 간에는 Message 방식
    - 데이터 병목 현상 최소화
    - 중간에 미들웨어 둠

---

### ❗️자료 구조

- `비선형` 구조 : `트리`, `그래프`
    - 트리 : 정점(노드)과 선분(가지)을 이용해 사이클을 이루지 않도록 구성한 그래프
- `선형` 구조 : `스택`, `큐`, `데크`, `리스트`
- 파일 구조 : 순차, 색인, 직접

---

### ❗️스택, 큐

- 스택(Stack) : LIFO(후입선출)
    - 한 쪽 끝으로만 삽입, 삭제
    - `Top, Bottom` 2개 포인터 갖음
    - 오버플로우 - 스택 공간이 가득 찼을 때 추가하려고 할 경우 일어남
    - 언더플로우 - 스택 공간에 데이터가 없는데 데이터 꺼내려 할 경우 일어남
- 큐(Queue) : `FIFO`(선입선출)
    - 한 쪽에서는 삽입, 다른 한 쪽에서는 삭제
    - `선택정렬`은 큐를 이용해 연산

---

### 알고리즘 설계 기법

- Divide and Conquer(`분할 정복` 알고리즘)
    - 그대로 해결할 수 없는 문제를 작은 문제로 분할하여 문제를 해결하는 알고리즘
- Greedy(`탐욕` 알고리즘)
    - 현재 시점에서 가장 최적의 방법을 선택하는 알고리즘
- `Backtracking`
    - 모든 조합을 시도하여 문제의 답을 찾는 알고리즘

---

### 이진 검색 알고리즘

- 탐색 효율이 좋고 탐색 시간 적게 소요
- 검색할 데이터가 정렬되어 있어야 함
- 비교횟수를 거듭할 때 마다 검색 대상이 되는 데이터의 수가 절반으로 줄어듦

---

### NS-Chart(Nassi-Schneiderman Chart)

- 논리 기술에 중점을 두고 도형을 이용한 표현 방법
- 이해 쉽고 코드 변환 용이
- 제어 논리 구조 표현

---

### 트리

- 전위 - Root -> Left -> Right
- 중위 - Left -> Root -> Right
- 후위 - Left -> Right -> Root
    
    => 순회 방식 모두 Left -> Right 방향은 공통
    
    => 부모 노드(Root) 방식 차이
    
    => 전위는 Root를 첫번째, 중위는 가운데, 후위는 마지막에 방문함
    

---

### 병행 제어 기법

- 동시에 여러 트랜잭션을 병행수행할 때 DB의 일관성을 파괴하지 않도록 제어
- `로킹 기법`
- `타임 스탬프 기법`
- `다중 버전 기법`
- 최적 병행 수행 기법(검증 기법, 확인 기법, 낙관적 기법)

---

### 정렬 소요 시간

- ❗️퀵정렬, `병합정렬` ⇒ 로그,변수에 비례
    - O(N*log_2N) 
    
- 버블정렬, 삽입정렬, 선택정렬  ⇒ 제곱에 비례
    - O(N^2)

---

### 힙 정렬(Heap Sort)

- 최악
    - O(nlogn)

---

### 선택정렬(Selection Sort)

- 정렬되지 않은 값 중 `가장 작은 값`을 선택 후 정렬되지 않은 첫 번째 요소와 `바꾸는` 방법

---

### 퀵정렬

- 레코드의 많은 자료 이동을 없애고 하나의 파일을 `부분적으로` 나누어 가면서 정렬

---

### 빌드 자동화 도구

- Jenkins
    - JAVA 기반 오픈소스
- `Gradle`
    - `Groovy`를 기반으로 한 오픈 소스 형태
    - `안드로이드` 앱 개발 환경에서 사용
    - 처리 명령들을 모아 태스크로 만든 후 태스크 단위로 실행
- Ant
- Maven

---

### 코드 인스펙션

- 모든 것이 `표준대로` 되어 있는 지 확인하기 위한 검토
- 표준이나 명세서에 서술한 내용과 비교하여 편차와 에러를 식별하기 위해 산출물을 근거로 수행하는 검사
- `정적 테스트`에 가까움

---

### 소스코드 정적 분석

- `프로그램 실행 없이` 코드 분석
- `코드 내` 보안 취약 발견 가능
- 규칙, 흐름에 맞는지 코드 점검

---

### ❗️소스코드 품질분석 도구

- 정적 분석 도구
    - `pmd`
    - cpp`check`
    - `check`style
- 동적 분석 도구
    - `valance`

---

### 외계인 코드

- 오래되거나 개발자가 `없어` 유지보수 작업이 어려운 프로그램

---

### 스파게티 코드

- 나쁜 코드
- 프로그램 로직이 복잡하여 이해하기 `어려운` 프로그램

---

### ❗️인터페이스 구현 검증 도구

- `STAF`
    - 서비스 호출, 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크
    - 각 테스트 대상 분산 환경에 데몬을 사용해 테스트 대상 프로그램을 통해 테스트 수행, 통합해 자동화하는 검증 도구
- `watir`
- `xUnit`
- Fitnesse
- `NTAF`
- Selenium

---

### ❗️인터페이스 보안

- 암호화
    - `IPSec`
        - 네트워크 계층에서 IP 패킷 단위의 데이터 변조 방지 및 은닉 기능 제공
    - `SSL`
        - TCP/IP 계층과 애플리케이션 계층 사이에서 인증, 암호화, 무결성을 보장하는 프로토콜
    - `S-HTTP`
        - 클라이언트와 서버 간 전송되는 모든 메시지를 암호화하는 프로토콜

---

### 디지털 저작권 관리(DRM)

- Contents Distributor
    - 암호화된 콘텐츠를 유통
- Packager
    - 콘텐츠를 메타데이터와 함께 배포 가능한 단위로 묶음
- DRM Controller
    - 배포된 콘텐츠의 이용권한을 통제

---

### ❗️DRM(디지털 저작권 관리) 기술요소

- 콘텐츠 `암호화, 키관리`
- 크랙방지
- 콘텐츠 `식별체계` 표현
- `라이센스` 발급 및 관리
- `정책 관리` 기술
- `암호화` 기술

---

### ISO/ISE `25010`

- 패키지 SW의 일반적인 제품 품질 요구사항 및 테스트를 위한 국제 표준

---

### ISO/IEC 9126 제품 특성

- 적합성
- 정확성
- 보안성

---

### 파티션

- 범위 분할(Range Partitioning)
    - 지정한 열의 값을 기준으로 분할
- 해시 분할(Hash Partitioning)
    - 해시 함수를 적용한 결과 값에 따라 데이터 분할
- 조합 분할(Composite Partitioning)
    - 범위 분할 후 해시 함수를 적용하여 다시 분할

---

### ❗️해싱함수

- 제곱법
- 숫자분석법
- 제산법
- `폴딩법`
    - 레코드 키를 여러 부분으로 나누고, 나눈 부분의 각 숫자를 더하거나 XOR한 값을 홈 주소로 사용하는 방식

---

### 반정규화 중 중복 테이블 추가 방법

- `집계` 테이블 추가
- `진행` 테이블 추가
- `특정` 부분만을 포함하는 `테이블` 추가

---

### 사용자 메뉴얼 준비 절차

- 작성 지침 정의 → 사용자 메뉴얼 구성 요소 정의 → 구성 요소별 내용 작성 → 사용자 메뉴얼 검토

---

### Fault(결함)

- 시스템

---

### Mistake(실수)

- 사람

---

### Bug

- Error 발생 == Bug 발견

---

### Debugging

- Error 수정 == Debugging

---

### SMTP(Simple Mail Transfer Protocol)

- 메일 전송에 사용되는 프로토콜

---
