---
layout: single
title: "[Certificate] 정보처리기사 필기 - [1과목] 소프트웨어 설계 - 총정리"
categories: Study
tag: [Study, Certificate]

toc: true
toc_sticky: true
published: true

date: 2022-04-22
last_modified_at: 2022-04-22

---


📄 [**정보처리기사 필기 기출 개정 후**](https://comcbt.com/xe/iz)를 공부하고 정리한 포스트입니다.
{: .notice--primary}

# [1과목] 소프트웨어 설계


### SW 설계

- `상위 설계`
    - 아키텍처 설계
    - 인터페이스 정의
    - 사용자 인터페이스 설계(UI 설계)
- 하위 설계
    - `모듈 설계`
    - 인터페이스 작성

---

### ❗️SW 설계에서 요구사항 분석

1. `도`출
2. `분`석 - `비용`, 일정에 대한 제약설정, 타당성 조사, 요구사항 정의 문서화
3. `명`세
4. `확`인

---

### SW개발 단계 중 유지보수 단계

- 개발 비용이 가장 많이 소요

---

### SW 개발에 이용하는 모델(Model)

- 향후 개발될 시스템을 유추하기 위해서 하는 활동이며, 주로 시스템 개발자가 실행

---

### ❗️애자일 개발 방법론

- 익스트림 프로그래밍(XP , eXtreme Programming)
- 스크럼 크리스털 패밀리
- `기능 주도 개발`(`FDD` , Feature-Driven Development)
- 적응형 소프트웨어 개발 (`ASD` , Adaptive Software Development
- 익스트림 모델링

---

### XP(eXtreme Programming)

1. `용기`
    - 고객 요구사항 변화에 능동적인 대처
2. 단순성
    - 부가적 기능・사용되지 않은 구조, 알고리즘 배제
3. `커뮤니케이션`
    - 개발자, 관리자, 고객 간 원활한 의사소통
4. `피드백`
    - 지속적인 테스트와 반복적 결함 수정, 빠른 피드백
5. 존중
    - 모든 프로젝트 관리자는 팀원의 기여를 존중

---

### SW 아키텍처

- 외부에서 인식할 수 있는 특성이 담긴 SW 골격이 되는 기본 구조
- 데이터 중심 아키텍처 - 접근자 수정, 확장 용이
- 이해 관계자들의 품질 요구사항 반영 ⇒ 품질 속성 결정
- ❗️`파이프-필터`
    - 서브 시스템이 입력 데이터를 받아 처리하고 결과를 다른 시스템에 보내 `작업 반복`하는 아키텍처
    - `단방향, 양방향` 모두 구현 가능
    - 필터간 이동시 `오버헤드` 발생
- 클라이언트 서버
    - 컴포넌트가 다른 컴포넌트에게 서비스를 요청
    - 데이터가 여러 컴포넌트 거치며 처리
- 계층구조
    - 모듈들로 응집된 계층 단위로 SW 구성
    - 계층 간 사용 가능의 관계로 표현
- MVC 구조
    - 모델-뷰-컨트롤러 기능을 분리

---

### SW 아키텍처 설계과정

1. 설계목표설정 
2. 시스템 타입 결정 
3. 아키텍처 패턴 적용 
4. 서브시스템 구체화 
5. 아키텍처 설계 `검토`

---

### SW 아키텍처 설계 - 시스템 품질 속성

- 가용성(Availability)
- `변경용이성(Modifiability)`
- 성능
- 보안성
- `사용성(Usability)`
- 시험성

---

### HIPO(Hierarchy Input Process Output)

- `하향식` 소프트웨어 개발
- 차트 종류 - 가시적 도표, 총체적 도표, 세부적 도표
- 기능, 자료의 의존 관계를 동시에 표현
- 보기 쉽고 이해 쉬움

---

### ❗️클래스 설계 원칙

1. 단일 책임원칙 : 하나의 객체는 하나의 동작만의 책임을 가짐
2. 개방-폐쇄의 원칙 : 클래스는 `확장에 대해 열려` 있어야 하며 변경에 대해 닫혀 있어야 함
3. `리스코프` 교체의 원칙 : 특정 메소드가 `상위 타입을 인자`로 사용할 때, 그 타입의 `하위 타입도` 문제 없이 작동해야 함
4. 의존관계 역전의 원칙 : 상위 계층이 하위 계층에 의존하는 전통적인 의존관계를 역전시킴으로써 상위 계층이 하위 계층의 구현으로부터 독립되게 할 수 있음

---

### UI 기본 원칙

- ❗️`직관성`
    - 누구나 쉽게 이해하고 사용할 수 있어야 함
- 유효성
    - 사용자의 목적을 `정확`하고 완벽하게 달성해야 함
- 학습성
    - 누구나 쉽게 배우고 익힐 수 있어야 함
- 유연성
    - 사용자의 요구사항을 최대한 `수용`하고 `실수`를 최소화해야 함

---

### UI 설계 도구

- 스토리보드 : 디자이너와 개발자가 최종적으로 참고하는 작업지침서
- 프로토타입 : 와이어프레임이나 스토리보드등에 인터랙션을 적용함으로써 실제 구현된 것처럼 테스트가 가능한 `동적인` 형태의 모형
- 유스케이스 : 사용자 측면에서의 요구사항으로, 사용자가 원하는 목표를 달성하기 위해 수행할 내용 기술
- `목업` : 실제 화면과 유사하게 만든 `정적인` 형태의 모형

---

### UML 다이어그램

- 활동 다이어그램
    - 시스템이 어떤 기능을 수행하는지 처리의 흐름을 순서에 따라 표현
- 상태 다이어그램
    - 클래스 상태 변화, 다른 객체와의 상호 작용에 따라 상태의 변화 표현
- `클래스 다이어그램`
    - 클래스 속성, 관계 표현
    - 시스템 구조 파악, 구조상 문제점 도출

---

### ❗️UML다이어그램 종류

- 구조적(정적) 다이어그램
    - 클객컴배복패
    - `클`래스, `객`체, `컴`포넌트, `배`치, `복`합체, `패`키지
- `행위(동적)` 다이어그램
    - 유시커상활타상
    - `유`스케이스, `시`퀀스, `커`뮤니케이션, `상`태, `활`동 `타`이밍, `상`호작용

---

### UML 구성요소

1. 사물(Thing)
2. `다이어그램(Diagram)`
3. `관계(Relationship)`

---

### UML 중 시퀀스 다이어그램

- `액`터
- `객`체
- `생`명선 - 점선
- `메`시지
- `실`행

---

### UML 구조

- Dependency(의존)
    - 한 사물의 명세서가 바뀌면 그것을 사용하는 다른 사물에게 `영향`을 끼치는 것
- Realization(실체화)
    - 한 객체가 다른 객체에 의해 오퍼레이션을 수행하도록 지정
- Generalization(일반화)
    - 일반화된 사물과 좀 더 `특수`화된 사물 사이의 관계('is-a')관계
- Association(연관)
    - 두 사물간의 `구조`적 관계 ⇒ 한 사물 객체가 다른 사물 객체와 연결되어 있음을 말함 ('has-a')관계

---

### UML 확장 모델

- << >>
    - 스트레오 타입 객체 표현

---

### Usecase

- 시스템의 액터에게 제공해야 하는 기능, 요구사항
- 액터
    - 시스템과 상호작용을 하는 모든 외부 요소
    - 주액터 - 사용자 액터
    - 부액터 - 시스템 액터

---

### Usecase 구성요소와의 관계

- 연관
    - Usecase와 Actor의 관계
- `확장`
    - 기본 Usecase 수행 시 `특별한 조건`을 만족할 때 수행
- 포함
    - 시스템의 기능이 별도의 기능을 포함
- 일반화
    - 하위 Usecase,Action이 상위 Usecase,Actor에게 기능, 역할을 상속 받음
- 그룹화
    - 여러 개의 Usecase를 단순화하는 방법

---

### AVL 트리

- 이진 트리의 `높낮이`가 불규칙해지는 것을 보완하여 `일정하게` 처리하기 위한 `이진트리` 모형

---

### ❗️**자료흐름도(DFD) = 버블 차트**

- 구조적 분석 기법
- 처리 `Process` : 원
- 자료흐름 `Data Flow` : 화살표
- 자료저장소 `Data Store` : 평행선
- 단말 `Terminal` : 사각형

⇒ `삼각형은 없음`

---

### ❗️GOF 디자인패턴

- 객체 지향 프로그래밍 설계를 할 때 `자주 발생하는 문제`들을 피하기 위해 사용되는 패턴.
- `생`성
    - 객체 생성
    - `추빌팩프싱` - 추상, 빌더, 팩토리 메소드, 프로토타입, 싱글톤
        - factory method - `상위클래스`에서 객체를 생성하는 인터페이스를 정의하고, `하위클래스`에서 인스턴스를 생성
        - Prototype - prototype 먼저 생성하고 인스턴스 복제해 사용
        - Singleton - 한 클래스 내에 한 객체만 존재
- `구`조
    - 구조를 통해 확장
    - `어브컴데퍼플프` - 어댑터, 브릿지, 컴포지트, 데코레이터, 퍼사이드, 플라이웨이트, 프록시
        - Adapter - 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록, 타 클래스의 인터페이스를 기존 인터페이스에 덧씌움
        - `bridge` - 구현부에서 추상층을 분리하여 각자 독립적으로 확장이 가능하게 하는 패턴
        - decorator - 0개, 1개 혹은 그 이상의 객체를 묶어 하나의 객체로 이용
- `행`위
    - 행위 변경, 수정
    - 생성, 구조 외 나머지 전부

---

### 객체지향 분석

- 업무(비즈니스)를 객체, 속성 등의 `개별요소`로 `추상화` 하는 기법

---

### 객체지향 분석 방법론

- ❗️`Coad-Youdon`
    - `E-R 다이어그램`을 사용해 객체 행위를 모델링
    - 객체 식별, 구조 식별
- Booch
    - 미시적, 거시적 개발 프로세스 모두 사용
- Jacobson
    - UseCase를 사용해 분석

---

### ❗️객체지향 분석기법 - Rumbaugh(럼바우)

객체 모델링 → 동적 모델링 → 기능 모델링

- 객체 = 객체 ⇒ `객2`
- 동적 = 상태 ⇒ `동상`
- 기능 = 자료 ⇒ `기자`

---

### 객체지향 기법

- `집단화`
    - part
- 일반화
    - 개념적인 `포함` 관계
- 캡슐화
    - 속성(데이터)과 메소드(연산)을 하나로 묶어 객체로 구성
- 추상화
    - `공통` 성질을 추출 ⇒ 수퍼클래스 구성

---

### 추상화

- `자`료 추상화
- `제`어 추상화
- `과`정 추상화

---

### 요구 사항 명세기법

- 정형 명세법
    - 사용자 요구를 표현할 때 수학적인 원리, 표기법 이용
    - 비정형 명세기법에 비해 표현이 간결
    - `Z모형`
- 비정형 명세법
    - 사용자 요구 표현 ⇒ 자연어 기반 서술
    - 상태, 기능, 객체 중심 명세법
    - UseCase - 사용자 기반 모델링
    - 명세 작성이 간편, 의사전달 방법 다양
    - 불충분한 명세가능성, 모호성

---

### 요구사항 검토 방법

- 동료 검토
    - 2-3명이 리뷰 형태로 작성자가 설명, 이해관계자가 설명 들으며 결함 발견
- `워크 스루`
    - 검토회의 전 명세서를 `미리 배포`해 사전 검토 후 짧은 회의 통해 오류 `조기 검출`
- 인스펙션
    - 명세서 작성자 제외한 다른 검토 `전문가`들이 확인하며 결함 발견

---

### 공통 모듈

- 전체 프로그램의 기능 중 특정 기능을 처리할 수 있는 실행코드
- 자체적으로 컴파일 기능, 다른 프로그램에서 재사용 가능

---

### 공통 모듈 원칙

- 정확성
    - 해당 기능이 실제 시스템 구현시 `필요`한지 알 수 있도록
- `명확성`
    - 해당 기능이 일관되게 이해하고 한가지로 해석될 수 있도록
- 완전성
    - 시스템이 구현될 떄 필요하고 요구되는 `모든 것` 기술
- 일관성
    - 공통 기능 간 `상호 충돌`이 없도록 작성
- 추적성
    - 공통 기능에 대한 요구사항 출처와 관련 시스템 등 유기적 관계에 대한 `식별`이 가능하도록 작성

---

### ❗️CASE(Computer-Aided Software Engineering)

- 시스템 개발 방법론들의 자동화를 지원하는 SW 도구를 제공해 개발자의 반복적인 작업량 줄이도록 하는 것
- `소프트웨어 생명주기 전 단계의 연결`
- `그래픽 지원`
- `다양한 소프트웨어 개발 모형 지원`

- `구조적` 기법
- 프로토타이핑 기술
- 자동프로그래밍 기술
- `정보 저장소` 기술
- 분산 처리 기술

---

### CASE

- 시스템 개발 과정 일부 또는 전체를 `자동화`
- 상위 CASE
    - 요구 분석과 설계 단계를 지원
        - 모델들 사이의 모순검사 기능
        - 모델의 오류 검증 기능
        - 자료흐름도 작성 기능
- 하위 CASE
    - 코드를 작성하고 테스트하며 문서화하는 과정 지원
        - `원시코드` 생성 기능
    - `통합 CASE`
    - 소프트웨어 개발 주기 `전체과정` 지원

---

### 시스템 구성 요소

- 입력 (Input)
- 처리 (Process)
- 출력 (Output)
- 제어 (Control)
    - 자료를 입력하여 출력될 때까지의 처리 과정이 올바르게 진행되는지 감독
- `피드백` (Feedback)
    - 출력된 결과가 예정된 목표를 만족시키지 못할 경우 목표 달성을 위해 반복 처리

---

### 분산 시스템

- `마스터-슬레이브 아키텍처`
    - `실시간 시스템`에서 사용
    - 마스터 - 작업을 분리, 배포, 슬레이브 프로세스 제어
    - `슬레이브` - 요청 작업 처리
- `미들웨어`
    - 복잡한 이기종 환경에서 응용 프로그램과 운영 환경간 원만한 통신을 이룰 수 있게 함
    - `프로그램-환경`, app- 사용자 사이 서비스 제공

---

### 시스템 연계 기술

- `소켓 기술`
    - 통신을 위한 Socket을 생성해 Port 할당
    - 클라이언트의 `통신 요청` 시 클리이언트와 연결하는 `내・외부 송・수신 연계` 기술

---

### 현행 시스템 분석

- DBMS 분석
- 네트워크 분석
- 운영체제 분석
- 플랫폼 기능, 성능 분석
- 비즈니스 융합 분석

---

### DBMS 분석

- `가용성`(무결성)
- `성능`(효율성)
- `상호 호환성`(일관성)
- 회복
- 보안
- DB 확장

---

### 요구 분석

- 기능적
    - 입력, 출력, DB, 통신 기능
- 비기능적
    - 성능 - 응답 속도, 자원 사용량
    - 보안 - 침입 대응, 탐지, 사용자 인증, 권한 부여

---

### ❗️미들웨어

- `WAS`(Web Application Server)
    - 애플리케이션 수행 미들웨어
- MOM(Message Oriented Middleware)
    - 메시지 지향 미들웨어
- `RPC`(Remote Procedure Call)
    - 원격 프로시저 호출
- `ORB`(Object Request Broker)
    - 객체 간 메시지 전달을 지원하는 미들웨어
- `TP monitor`
    - 트랜잭션이 처리를 감시, 제어하는 미들웨어

---

### ❗️코드 종류

- `표의 숫자 코드`
    - 코드화 대상 항목의 중량, 면적, 용량 등 `물리적 수치` 이용
- `순차 코드`
    - 자료의 발생순, 크기순, 가나다순 등 `일정 순서`대로 코드
- 10진 코드
- 블록 코드
    - 구분 코드
- 연상코드
    - 항목의 명칭, 약호와 관계 있는 숫자, 문자, 기호 이용

---

### ❗️자료사전(Data Dictionary)

- =
    - 자료의 정의(~로 구성되어 있다)
- +
    - 자료의 연결(그리고)
- ()
    - 자료의 생략(생략 가능한 자료)
- []
    - 자료의 `선택`(또는)
- {}
    - 자료의 `반복`
- **
    - 자료의 설명(주석)

---

### EAI(Enterprise Application Integration)

- 기업 응용 프로그램 통합

---

### FEP(Front-End Processor)

- 입력되는 데이터를 컴퓨터의 프로세서가 처리하기 전에 미리 처리하여 프로세서가 차지하는 `시간을 줄여`주는 프로그램이나 하드웨어

---

### GPL(General Public License)

- 자유 소프트웨어 재단(OSF)에서 만든 자유 소프트웨어 라이센스

---

### Duplexing

- 이중화(DB 회복 기법 중 가장 간단)

---

### fan-in, fan-out

- 모듈을 제어하는 수 ⇒ `상`위 ⇒ fan-`in`
- 모듈이 제어하는 수 ⇒ 하위 ⇒ fan-out

---

### 리눅스 용어

- ls
    - List
    - 디렉토리 목록 출력
- cat
    - 파일 출력
- pwd
    - Print Working Directory
    - 현재 디렉토리 출력
- uname
    - 시스템 정보 출력

---

### 협약에 의한 설계

1. 선행조건
    - 오퍼레이션이 호출되기 전에 참이 되어야 할 조건
2. 결과조건
    - 오퍼레이션이 수행된 후 만족하여야 하는 조건
3. 불변조건
    - 클래스 내부가 실행되는 동안 항상 만족해야 하는 조건

---

### 플랫폼 성능특성 분석 측정항목

1. 응답시간
    - 사용자가 응답을 받기까지 걸리는 총 시간
2. 가용성
    - 서비스가 정상적으로 유지되는 시간
3. 사용률
    - 사용된 자원의 사용량
